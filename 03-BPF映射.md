通过传递消息来调用一个程序中的行为是软件工程中广泛使用的技术。一个程序可以通过发送消息来修改另一个程序的行为，这也允许在这些程序之间交换信息。 BPF最令人着迷的方面之一是，内核上运行的代码和加载了该代码的程序可以在运行时使用消息传递相互通信。

在这一章中，我们介绍了BPF程序和用户态程序如何相互通信。我们描述了内核和用户态之间不同的通信渠道，以及它们如何存储信息。我们还将向您展示这些通道的用例，以及如何使这些通道中的数据在程序初始化之间保持不变。

BPF映射是驻留在内核中的键/值存储。任何BPF程序都可以访问它们。在用户态中运行的程序也可以使用文件描述符访问这些映射。只要事先正确指定数据大小，就可以在映射中存储任何类型的数据。内核将键和值视为二进制 blobs，它并不关心您在映射中保留的内容。

BPF验证程序包括多种保护措施，以确保您创建和访问映射的方式是安全的。当我们解释如何访问这些映射中的数据时，我们也将解释这些保护措施。

### 创建 BPF 映射

创建BPF映射的最直接方法是使用bpf syscall。当调用中的第一个参数是BPF_MAP_CREATE时，您将告诉内核您要创建一个新映射。此调用将返回与您刚创建的映射关联的文件描述符标识符。 syscall中的第二个参数是此映射的配置：

```c
    union bpf_attr {
        struct {
            __u32 map_type;     /* one of the values from bpf_map_type */
            __u32 key_size;     /* size of the keys, in bytes */
            __u32 value_size;   /* size of the values, in bytes */
            __u32 max_entries;  /* maximum number of entries in the map */ 
            __u32 map_flags;    /* flags to modify how we create the map */
        };
    }
```

syscall中的第三个参数是此配置属性的大小。


例如，您可以创建一个哈希表映射来存储无符号整数作为键和值，如下所示：

```c
    union bpf_attr my_map { 
        .map_type = BPF_MAP_TYPE_HASH, 
        .key_size = sizeof(int), 
        .value_size = sizeof(int), 
        .max_entries = 100,
        .map_flags = BPF_F_NO_PREALLOC,
    };

    int fd = bpf(BPF_MAP_CREATE, &my_map, sizeof(my_map));
```

如果调用失败，则内核返回值-1。失败的原因可能有三个。如果其中一个属性无效，则内核将errno变量设置为EINVAL。如果执行该操作的用户没有足够的特权，则内核将errno变量设置为EPERM。最后，如果没有足够的内存来存储映射，则内核将errno变量设置为ENOMEM。

在以下各节中，我们将通过不同的示例指导您，向您展示如何使用BPF映射执行更高级的操作。让我们从一种更直接的方式开始创建任何类型的映射。

#### ELF创建BPF映射的约定

内核包括一些约定和帮助程序，用于生成和使用BPF映射。与直接执行系统调用相比，您可能会发现这些约定的出现频率更高，因为它们更具可读性且易于遵循。请记住，即使直接在内核中运行，这些约定仍会使用bpf syscall来创建映射，如果您事先不知道要使用哪种映射，则直接使用syscall会更有用。

帮助程序函数 bpf_map_create 封装了您刚刚看到的代码，从而使按需初始化映射更加容易。我们可以使用它仅用一行代码来创建先前的映射：

```c

    int fd;
    fd = bpf_create_map(BPF_MAP_TYPE_HASH, sizeof(int), sizeof(int), 100,
            BPF_F_NO_PREALOC);

```

如果知道程序中需要哪种映射，也可以预先定义。这对于增加程序中使用的映射的可见性有很大帮助：

```c
    struct bpf_map_def SEC("maps") my_map = { 
        .type = BPF_MAP_TYPE_HASH, 
        .key_size = sizeof(int), 
        .value_size = sizeof(int), 
        .max_entries = 100,
        .map_flags =BPF_F_NO_PREALLOC, 
    };
```

以这种方式定义映射时，您使用的是 "section" 属性，在本例中为SEC("maps")。该宏告诉内核此结构是BPF映射，应该相应地创建它。

您可能已经注意到，在这个新示例中，我们没有与映射关联的文件描述符标识符。在这种情况下，内核使用名为map_data的全局变量将有关映射的信息存储在程序中。此变量是一个结构数组，根据您在代码中指定每个映射的方式进行排序。例如，如果先前的映射是代码中指定的第一个映射，则可以从数组的第一个元素获取文件描述符标识符：

```c
    fd = map_data[0].fd;
```

您还可以从此结构访问映射的名称及其定义；此信息
有时对于调试和追踪的目的很有用。

初始化映射后，可以开始在内核和用户态之间使用它们发送消息。现在，让我们看看如何使用这些映射存储的数据。

#### 使用 BPF 映射

内核和用户态之间的通信将成为您编写的每个BPF程序的基本组成部分。当您为内核编写代码时，与为用户态程序编写代码时，访问映射的API不同。本节介绍每种实现的语义和特定细节。

##### 更新 BPF 映射中的元素

创建完任何映射后，您可能要做的第一件事就是向其中填充信息。内核助手为此提供了函数 bpf_map_update_elem。如果在内核运行的程序中从bpf/bpf_helpers.h 加载该函数，则与在用户态运行的程序中从 tools/lib/bpf/bpf.h 加载该函数的签名不同。这是因为您在内核中工作时可以直接访问映射，但是在用户态中工作时可以使用文件描述符来引用它们。它的行为也略有不同。在内核上运行的代码可以直接访问内存中的映射，并且将能够原子地就地更新元素。但是，在用户态中运行的代码必须将消息发送到内核，内核会在更新映射之前复制提供的值；这使得更新操作不是原子的。该函数在操作成功时返回0，在操作失败时返回负数。如果发生失败，则用失败原因填充全局变量errno。接下来，我们将在本章详细罗列出失败案例。

内核中的 bpf_map_update_elem 函数采用四个参数。第一个是指向我们已经定义的映射的指针。第二个是指向我们要更新的元素的Key的指针。由于内核不知道我们要更新的Key的类型，因此此方法定义为指向void的不透明指针，这意味着我们可以传递任何数据。第三个参数是我们要插入的值。此变量的使用与Key变量的使用相同。在本书中，我们将展示一些高级示例，说明如何利用不透明指针。您可以在此函数中使用第四个参数来更改映射的更新方式。此参数可以采用三个值：

- 如果您传递0，则表示内核要更新元素（如果存在），或者如果不存在则应在映射中创建该元素。

- 如果传递1，则告诉内核仅在元素不存在时才创建它。

- 如果传递2，则内核仅在元素存在时才对其进行更新。

这些值被定义为常量，您也可以使用它们，而不必记住整数语义。值如下：BPF_ANY表示0，BPF_NOEX IST表示1，BPF_EXIST表示2。

让我们使用上一节中定义的映射来编写一些示例。在第一个示例中，我们向映射添加了一个新值。由于映射为空，因此我们可以假设任何更新行为对我们都有利：

```c
    int key, value, result; 
    key = 1, value = 1234;

    result = bpf_map_update_elem(&my_map, &key, &value, BPF_ANY); if (result == 0)
        printf("Map updated with new element\n"); 
    else
        printf("Failed to update map with new value: %d (%s)\n", result, strerror(errno));

```

在此示例中，我们使用strerror来描述errno变量中设置的错误。您可以使用man strerror在手册页上了解有关此函数的更多信息。

