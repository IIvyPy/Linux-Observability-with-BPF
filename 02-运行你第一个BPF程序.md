BPF VM能够运行指令以响应内核触发的事件。但是，并非所有BPF程序都可以访问由内核触发的所有事件。当你将程序加载到BPF VM中时，需要确定要运行的程序类型。这将通知内核您的程序将在哪里触发。它还告诉BPF验证程序将允许您的程序中运行哪些帮助函数。选择程序类型后，你也选择了程序要实现的接口。此接口确保您可以访问适当类型的数据，以及您的程序是否可以直接访问网络数据包。

在本章中，我们向您展示如何编写您的第一个BPF程序。我们还将介绍可创建的不同类型的BPF程序（本书编写时）。多年来，内核开发人员一直在添加不同的入口点，可以将BPF程序附加到这些入口点。这项工作尚未完成，他们每天都在寻找新的方法来利用BPF。我们将在本章中重点介绍一些最有用的程序类型，以使您了解使用BPF可以做什么。在以后的章节中，我们将介绍许多有关如何编写BPF程序的示例。

本章还将介绍BPF验证程序在运行程序中所扮演的角色。此组件可验证您的代码可以安全执行，并帮助您编写不会导致意外结果（例如内存耗尽或内核突然崩溃）的程序。但是，让我们从编写您自己的BPF程序的基础知识开始。

### 编写 BPF 程序
编写BPF程序的最常见方法是使用LLVM编译的C子集。 LLVM是一种通用编译器，可以编译出不同类型的字节码。在这种情况下，LLVM将输出BPF汇编代码，我们稍后将其加载到内核中。本书中不会向您介绍很多BPF汇编。经过长时间的讨论，我们决定最好向您展示在特定情况下如何使用它的示例，但是您可以在网上或BPF手册页中轻松找到一些参考。我们确实会在以后的章节中显示BPF汇编的简短示例，在这些示例中，编写汇编比C更合适，例如Seccomp过滤器可控制内核中传入的系统调用。我们将在第8章中进一步讨论Seccomp。

内核提供syscall bpf，以便在编译程序后将程序加载到BPF VM中。除了加载程序外，该系统调用还用于其他操作，您将在后面的章节中看到更多用法示例。内核还提供了一些实用程序，可以为您抽象BPF程序的加载。在第一个代码示例中，我们使用这些帮助程序向您展示BPF的“ Hello World”示例：

```c
#include <linux/bpf.h>

#define SEC(NAME) __attribute__((section(NAME), used))
SEC("tracepoint/syscalls/sys_enter_execve") 
int bpf_prog(void *ctx) {
    char msg[] = "Hello, BPF World!"; 
    bpf_trace_printk(msg, sizeof(msg)); 
    
    return 0;
}

char _license[] SEC("license") = "GPL";
```

在第一个程序中有一些有趣的概念。当我们要运行此程序时，我们使用SEC属性通知BPF VM。在这种情况下，当execve 系统调用被检测到时，我们将运行此BPF程序。跟踪点是内核二进制代码中的静态标记，允许开发人员注入代码以检查内核的执行情况。我们将在第4章中详细讨论跟踪点，但是现在您只需要知道execve是执行其他程序的指令即可。因此，我们将看到消息Hello，BPF World！每次内核检测到某个程序执行另一个程序时。

在此示例的最后，我们还指定了该程序的许可证。由于Linux内核是根据GPL许可的，因此它也只能加载以GPL许可的程序。如果我们将许可证设置为其他权限，内核将拒绝加载程序。我们正在使用bpf_trace_printk在内核跟踪日志中打印一条消息；您可以在 /sys/kernel/debug/tracing/trace_pipe 中找到此日志。

我们将使用clang将第一个程序编译为有效的ELF二进制文件。这是内核期望加载的格式。我们将第一个程序保存在名为bpf_program.c的文件中，以便我们对其进行编译：
```sh
clang -O2 -target bpf -c bpf_program.c -o bpf_program.o
```
在该书的代码示例中，您会在GitHub存储库中找到一些脚本来编译这些程序，因此您无需记住此clang命令。

现在，我们已经编译了第一个BPF程序，我们需要将其加载到内核中。如前所述，我们使用内核提供的特殊帮助函数来抽象出编译和加载程序的模板。该帮助函数称为load_bpf_file，它将获取一个二进制文件，然后尝试将其加载到内核中。您可以在GitHub存储库中找到该帮助函数，并在书中的所有示例都位于bpf_load.h文件中，如下所示：

```c
#include <stdio.h>
#include <uapi/linux/bpf.h>
#include "bpf_load.h"

int main(int argc, char **argv) {
    if (load_bpf_file("hello_world_kern.o") != 0) {
        printf("The kernel didn't load the BPF program\n");

        return -1; 
    }

    read_trace_pipe(); 

    return 0;
}
```

我们将使用脚本来编译该程序并将其链接为ELF二进制文件。在这种情况下，我们不需要指定目标，因为该程序不会加载到BPF VM中。我们需要使用一个外部库，编写脚本可以更轻松地将所有内容组合在一起：
```sh
    TOOLS=../../../tools
    INCLUDE=../../../libbpf/include
    HEADERS=../../../libbpf/src
    clang -o loader -l elf \
      -I${INCLUDE} \
      -I${HEADERS} \
      -I${TOOLS} \
      ${TOOLS}/bpf_load.c \
      loader.c
```

如果要运行此程序，则可以使用sudo执行此最终二进制文件：sudo ./loader。 sudo是Linux命令，它将为您提供计算机的root特权。如果您不使用sudo运行该程序，则会收到错误消息
因为大多数BPF程序只能由具有root特权的用户加载到内核中。

运行该程序时，您将开始看到我们的“ Hello, BPF World”！几秒钟后仍会显示一条消息，即使您没有使用计算机进行任何操作。这是因为在计算机屏幕后运行的程序可能正在执行其他程序。

当您停止该程序时，该消息将停止在您的终端中显示。如果是从终端的方式加载的BPF程序，当停止的时候，BPF程序就会从VM中卸载。在接下来的章节中，我们将探讨如何使BPF程序持久化，即使它们的加载程序终止后也是如此，但是我们现在还不想引入太多概念。这是一个切记的重要概念，因为在许多情况下，无论其他进程是否在运行，您都希望BPF程序在后台运行。

既然您已经了解了BPF程序的基本结构，我们就可以深入研究可以编写哪些类型的程序，从而可以访问Linux内核中的不同子系统。

### BPF 程序类型

虽然没有明确在程序中进行分类，您会很快意识到，本节中介绍的所有类型都根据其主要目的分为两类。

第一类是追踪。您编写的许多程序将帮助您更好地了解系统中正在发生的事情。它们为您提供有关系统行为及其运行硬件的直接信息。他们可以访问与特定程序有关的内存区域，并从运行进程中提取执行的追踪信息。它们还使您可以直接访问为每个特定进程分配的资源，从文件描述符到CPU和内存使用情况。

第二类是网络。这些类型的程序使您可以检查和处理系统中的网络流量。它们使您可以过滤来自网络接口的数据包，甚至完全拒绝那些数据包。可以在内核中将不同类型的程序附加到网络处理的不同阶段。这具有优点和缺点。例如，您可以在网络驱动程序收到数据包后立即将BPF程序附加到网络事件中，但是此程序将只能访问较少的有关该数据包的信息，因为内核尚不足以为您提供信息。另一方面，您可以将BPF程序附加到网络事件上，然后再将它们传递到用户态。在这种情况下，您将获得有关数据包的更多信息，这将有助于您做出更明智的决策，但是您需要承担完全处理数据包的开销。

接下来我们介绍一些未分类的程序类型。我们将按照添加到内核的时间顺序介绍这些类型。我们将这些程序中使用最少的程序移到了本节的结尾，现在我们将重点放在对您更有用的程序上。如果您对我们在此处未详细介绍的任何程序感到好奇，可以在[man 2 bpf](http://man7.org/linux/man-pages/man2/bpf.2.html)中了解有关所有程序的更多信息。

#### 套接字过滤器程序（Socket Filter Programs）
`BPF_PROG_TYPE_SOCKET_FILTER` 是添加到Linux内核的第一个程序类型。当您将BPF程序附加到原始套接字时，就可以访问该套接字处理的所有数据包。套接字过滤器程序不允许您修改这些数据包的内容或更改这些数据包的目的地；它们仅允许您出于可观察性目的访问它们。程序接收的元数据包含与网络栈相关的信息，例如用于传送数据包的协议类型。
我们将在第6章中详细介绍套接字过滤和其他网络程序。

#### Kprobe 程序（Kprobe Programs）

正如您将在第4章中讨论的追踪中所看到的那样，kprobes是可以动态附加到内核中某些调用点的函数。 BPF kprobe程序类型允许您将BPF程序用作kprobe处理程序。它们以`BPF_PROG_TYPE_KPROBE` 类型定义。 BPF VM确保您的kprobe程序始终安全运行，这是传统kprobe模块的优势。您仍然需要记住，kprobes在内核中不是稳定的入口点，因此，您需要确保kprobe BPF程序与您使用的特定内核版本兼容。

编写附加到kprobe的BPF程序时，您需要决定是将其作为函数调用中的第一条指令执行还是在调用完成时执行。您需要在BPF程序的标头中声明此行为。例如，如果您要在内核调用exec syscall时检查参数，则可以在调用开始时附加程序。在这种情况下，您需要在代码段开始处设置SEC（“kprobe/sys_exec”）。如果要检查调用exec syscall的返回值，则需要在代码段开始处设置SEC（“kr​​etprobe/ sys_exec”）。

在本书的后续章节中，我们会更多地讨论kprobes。它们是理解BPF追踪的基础。

#### 追踪点程序（Tracepoint Programs）

这种程序类型使您可以将BPF程序附加到内核提供的跟踪点处理程序。追踪点程序以`BPF_PROG_TYPE_TRACEPOINT`类型定义。如第4章中所述，追踪点是内核代码库中的静态标记，可让您注入任意代码以进行追踪和调试。它们不如kprobes灵活，因为它们需要事先由内核定义，但是可以保证在将其引入内核后保持稳定。当您要调试系统时，这为您提供了更高的可预测性。
系统中的所有追踪点都在目录 /sys/kernel/debug/tracing/events 中定义。在这里，您将找到每个子系统，其中包括任何追踪点，并且可以将BPF程序附加到该子系统。一个有趣的事实是BPF声明了自己的追踪点，因此您可以编写检查其他BPF程序行为的BPF程序。 BPF跟踪点在 /sys/kernel/debug/tracing/events /bpf 中定义。例如，您可以在此处找到bpf_prog_load的追踪点定义。这意味着您可以编写一个BPF程序来检查何时加载其他BPF程序。

像kprobes一样，追踪点是了解BPF追踪的另一个基本要素。在接下来的章节中，我们将进一步讨论它们，并向您展示如何编写程序以使用它们。

#### XDP程序（XDP Programs）
XDP程序使您可以编写在网络数据包到达内核的早期就执行的代码。它们以 `BPF_PROG_TYPE_XDP` 类型定义。假设内核没有太多时间来处理信息本身，那么它仅从包中公开有限的信息集。由于数据包是在早期执行的，因此您对如何处理该数据包具有更高级别的控制。

XDP程序定义了几个可以控制的操作，这些操作使您可以决定如何处理数据包。您可以从XDP程序返回 XDP_PASS，这意味着应该将数据包传递到内核中的下一个子系统。您还可以返回 XDP_DROP，这意味着内核应完全忽略此数据包，并且对其不执行任何其他操作。您还可以返回XDP_TX，这意味着应将数据包转发回首先接收到数据包的网络接口卡（NIC）。

这种控制级别为网络层中许多有趣的程序打开了大门。 XDP已成为BPF的主要组件之一，这就是为什么我们在本书中包含了特定章节的原因。在第7章中，我们讨论了许多XDP用例，例如实现程序以保护您的网络免受DDoS攻击。

#### Perf事件程序（Perf Event Programs）

这些类型的BPF程序使您可以将BPF代码附加到Perf事件。它们以 `BPF_PROG_TYPE_PERF_EVENT` 类型定义。 Perf是内核中的性能分析器，它能够生成硬件和软件的性能数据。您可以使用它来监控许多事情，从计算机的CPU到系统上运行的任何软件。当您将BPF程序附加到Perf事件时，每次Perf生成供您分析的数据时，都将执行您的代码。

#### Cgroup套接字程序（Cgroup Socket Programs）

这些类型的程序使您可以将BPF逻辑附加到控制组（cgroup）。它们以 `BPF_PROG_TYPE_CGROUP_SKB` 类型定义。它们允许cgroup控制它们所包含的进程内的网络流量。借助这些程序，您可以在将网络数据包传递到cgroup中的进程之前决定如何处理它。内核尝试传递到同一cgroup中任何进程的任何数据包都将通过每一个过滤器。同时，您可以决定cgroup中的进程通过该接口发送网络数据包时该怎么做。
如您所见，它们的行为类似于 `BPF_PROG_TYPE_SOCKET_FILTER` 程序。主要区别在于
`BPF_PROG_TYPE_CGROUP_SKB` 程序附加到cgroup内的所有进程，而不是特定进程；此行为适用于在给定cgroup中创建的当前套接字和将来的套接字。附加到cgroup的BPF程序在容器环境中很有用，在容器环境中，进程组受cgroup约束，并且您可以对所有进程应用相同的策略，而不必独立识别每个进程。 [Cillium](https://github.com/cilium/cilium)是一个受欢迎的开源项目，为Kubernetes提供负载平衡和安全功能，它广泛使用cgroup套接字程序将其策略应用于组而不是隔离的容器中。

#### Cgroup打开套接字程序（Cgroup Open Socket Programs）

这些类型的程序允许您在cgroup中的任何进程打开网络套接字时执行代码。此行为类似于附加到cgroup套接字缓冲区的程序，与其给您访问通过网络的数据包的权限，不如让您控制进程打开新套接字时发生的情况。它们以 `BPF_PROG_TYPE_CGROUP_SOCK` 类型定义。这对于为可以打开套接字的程序组提供安全性和访问控制很有用，而不必分别限制每个进程的功能。

#### 套接字选项程序（Socket Option Programs）

这些类型的程序可让您在运行时修改套接字连接选项，而数据包则通过内核网络栈中的多个阶段传输。他们
附加到cgroup，就像 `BPF_PROG_TYPE_CGROUP_SOCK` 和 `BPF_PROG_TYPE_CGROUP_SKB` 一样，但是与这些程序类型不同，它们可以在连接的生命周期中多次调用。这些程序以 `BPF_PROG_TYPE_SOCK_OPS` 类型定义。

当您用这种类型创建一个BPF程序时，您的函数调用将收到一个名为op的参数，该参数代表内核将通过套接字连接执行的操作。因此，您知道在连接的生命周期中何时调用该程序。有了这些信息，您就可以访问诸如网络IP地址和连接端口之类的数据，并且可以修改连接选项以设置超时并更改给定数据包的往返延迟时间。

例如，Facebook使用它为同一数据中心内的连接设置短恢复时间目标（RTO）。 RTO是指系统或网络连接在这种情况下在出现故障后可以恢复的时间。该目标还表示在遭受无法接受的后果之前，该系统无法使用多长时间。以Facebook为例，它假设同一数据中心中的计算机应具有较短的RTO，而Facebook使用BPF程序修改此阈值。

#### 套接字映射程序（Socket Map Programs）

`BPF_PROG_TYPE_SK_SKB` 程序使您可以访问套接字映射和套接字重定向。正如您将在下一章中学习的那样，套接字映射允许您保留对多个套接字的引用。当拥有这些引用时，可以使用特殊的辅助函数将传入的数据包从套接字重定向到另一个套接字。当您要使用BPF实现负载平衡功能时，这很有趣。通过追踪多个套接字，您可以在它们之间转发网络数据包而无需离开内核空间。诸如Cillium和Facebook的[Katran](https://github.com/facebookincubator/katran)之类的项目广泛使用了这类程序来进行网络流量控制。

#### Cgroup 设备程序（Cgroup Device Programs）
此类程序可让您决定是否可以在给定设备上执行cgroup中的操作。这些程序以`BPF_PROG_TYPE_CGROUP_DEVICE` 类型定义。 cgroups（v1）的第一个实现具有一种机制，允许您为特定设备的设置权限。但是，cgroup的第二版迭代缺少此功能。引入了此类程序以提供该功能。同时，能够编写BPF程序使您在需要时可以更灵活地设置这些权限。

#### 套接字消息传输程序（Socket Message Delivery Programs）


这些类型的程序使您可以控制是否消息应该被传递到套接字。它们以 `BPF_PROG_TYPE_SK_MSG` 类型定义。当内核创建套接字时，它将套接字存储在上述套接字映射中。该映射使内核可以快速访问特定的套接字组。当您将套接字消息BPF程序附加到套接字映射时，发送到这些套接字的所有消息将在传递它们之前被程序过滤。在过滤消息之前，内核会复制消息中的数据，以便您可以读取它并决定如何处理它。这些程序有两个可能的返回值：`SK_PASS`和`SK_DROP`。如果希望内核将消息发送到套接字，则使用第一个消息；如果希望内核忽略消息而不将消息传递到套接字，则使用后一个消息。

#### 原始追踪点程序（Raw Tracepoint Programs）

前面我们讨论了一种访问内核中追踪点的程序。内核开发人员添加了一个新的追踪点程序，以解决访问内核保留的原始格式的跟踪点参数的需求。这种格式使您可以访问有关内核正在执行的任务的更多详细信息；但是，它的性能开销很小。大多数时候，您会希望在程序中使用常规跟踪点来避免这种性能开销，但是请记住，您还可以在需要时使用原始追踪点来访问原始参数。这些程序以`BPF_PROG_TYPE_RAW_TRACE POINT` 类型定义。

#### Cgroup套接字地址程序（Cgroup Socket Address Programs）


使用此类程序，当用户态程序受特定cgroup控制时，您可以操纵它们附加到的IP地址和端口号。在某些情况下，如果要确保一组特定的用户态程序使用相同的IP地址和端口，则系统使用多个IP地址。当您将这些用户态程序放在同一cgroup中时，这些BPF程序使您可以灵活地操作这些绑定。这样可以确保这些应用程序的所有传入和传出连接都使用BPF程序提供的IP和端口。这些程序以 `BPF_PROG_TYPE_CGROUP_SOCK_ADDR` 类型定义。

#### 套接字重用程序（Socket Reuseport Programs）

SO_REUSEPORT 是内核中的一个选项，它允许将同一主机中的多个进程绑定到同一端口。当您要在多个线程之间分配负载时，此选项可在接受的网络连接中提供更高的性能。
`BPF_PROG_TYPE_SK_REUSEPORT` 程序类型允许您编写BPF程序，这些程序钩子到内核用来决定是否要重用端口的逻辑中。如果您的BPF程序返回`SK_DROP`，则可以防止程序重用同一端口，并且当您从这些BPF程序返回`SK_PASS`时，还可以通知内核遵循其自己的重用例程。

#### 分流器程序（Flow Dissection Programs）

分流器是内核的一个组件，从网络数据包到达你的系统开始到数据包传递到你的用户态程序的时间内，追踪经过不同层的网络数据包。它允许您使用不同的分类方法来控制数据包的流向。内核中的内置解剖器称为`Flower classifier`，防火墙和其他过滤设备使用它来决定如何处理特定的数据包。
BPF_PROG_TYPE_FLOW_DISSECTOR程序设计为在流分解器路径中挂钩逻辑。它们提供内置解剖器无法提供的安全性保证，例如确保程序始终终止，而内置解剖器可能无法保证。这些BPF程序可以修改网络数据包在内核中遵循的流。

#### 其他 BPF 程序
我们已经讨论了不同场景下使用的程序类型，但是值得注意的是，我们还没有涉及其他一些BPF程序类型。这些是我们在这里仅简要提及的程序：

- 流量分类程序 （Traffic classifier programs）。

    `BPF_PROG_TYPE_SCHED_CLS` 和`BPF_PROG_TYPE_SCHED_ACT` 是两种BPF程序，可用于分类网络流量并修改套接字缓冲区中数据包的某些属性。

- 轻量级隧道程序（Lightweight tunnel programs）。

    `BPF_PROG_TYPE_LWT_IN`，`BPF_PROG_TYPE_LWT_OUT`，`BPF_PROG_TYPE_LWT_XMIT`和`BPF_PROG_TYPE_LWT_SEG6LOCAL`是BPF程序的类型，可用于将代码附加到内核的轻量级隧道基础架构。

- 红外设备程序（Infrared device programs）

    `BPF_PROG_TYPE_LIRC_MODE2` 程序允许您通过连接将BPF程序附加到红外设备（例如遥控器）来获得乐趣。

这些程序是用于指定领域的，其用法尚未为社区广泛采用。

接下来，我们讨论BPF如何保证您的程序在内核加载后不会导致系统崩溃。这是一个重要的话题，
因为了解程序的加载方式也会影响如何编写这些程序。

### BPF 校验器

起初，允许任何人在Linux内核中执行任意代码总是听起来很糟糕。如果不使用BPF验证程序，则在生产系统中运行BPF程序的风险会很高。用内核网络维护者之一Dave S. Miller的话说：“我们的eBPF程序与破坏深深的黑暗鸿沟之间唯一的东西就是eBPF验证程序。”

显然，BPF验证程序也是在您的系统上运行的程序，因此，对其进行严格审查是确保其正确执行工作的目标。在过去的几年中，安全研究人员发现了验证程序中的一些漏洞，这些漏洞使攻击者甚至可以以特权用户身份访问内核中的随机内存。您可以在“常见漏洞和披露（CVE）”目录中阅读有关此类漏洞的更多信息，该目录是美国国土安全部赞助的一系列已知安全线程。例如，CVE-2017-16995描述了任何用户如何读写内核内存并绕过BPF验证程序。

在本节中，我们将指导您完成验证器为避免上述问题而采取的措施。

验证程序执行的第一项检查是对VM即将加载的代码的静态分析。第一次检查的目的是确保程序有预期的结果。为此，验证程序将使用代码创建有向循环图（DAG）。验证程序分析的每个指令将成为图中的一个节点，并且每个节点都链接到下一条指令。验证程序生成此图后，它将执行深度优先搜索（DFS），以确保程序完成并且代码不包含危险路径。这意味着它将遍历图的每个分支，一直到分支的底部，以确保没有递归循环。

这些是验证器在第一次检查期间可能拒绝您的代码的情形，要求有以下几个方面：

- 该程序不包含控制循环。为确保程序不会陷入无限循环，验证程序会拒绝任何类型的控制循环。已经提出了在BPF程序中允许循环的建议，但是截至撰写本文时，没有一个被采用。

- 该程序不会尝试执行超过内核允许的最大指令数的指令。此时，可执行的最大指令数为4,096。此限制是为了防止BPF永远运行。在第3章，我们讨论如何嵌套不同的BPF程序，以安全的方式解决此限制。

- 该程序不包含任何无法访问的指令，例如从未执行过的条件或功能。这样可以防止在VM中加载无效代码，这也会延迟BPF程序的终止。

- 该程序不会尝试越界。

验证者执行的第二项检查是BPF程序的空运行。这意味着验证者将尝试分析程序将要执行的每条指令，以确保它不会执行任何无效的指令。此执行还将检查所有内存指针是否均已正确访问和取消引用。最后，空运行向验证程序通知程序中的控制流，以确保无论程序采用哪个控制路径，它都会到达BPF_EXIT指令。为此，验证程序会追踪堆栈中所有访问过的分支路径，并在采用新路径之前对其进行评估，以确保它不会多次访问特定路径。经过这两项检查后，验证者认为程序可以安全执行。

如果您有兴趣查看程序的分析方式，则可以使用bpf syscall调试验证程序的检查。使用此syscall加载程序时，可以设置几个属性，这些属性将使验证程序打印其操作日志：

```c
union bpf_attr attr = { 
    .prog_type = type,
    .insns = ptr_to_u64(insns), 
    .insn_cnt = insn_cnt,
    .license =ptr_to_u64(license), 
    .log_buf =ptr_to_u64(bpf_log_buf), 
    .log_size = LOG_BUF_SIZE, 
    .log_level = 1,
};

bpf(BPF_PROG_LOAD, &attr, sizeof(attr));
```

log_level字段告诉验证器是否打印任何日志。如果将其设置为1，它将打印其日志；如果将其设置为0，它将不打印任何内容。如果要打印验证程序日志，还需要提供日志缓冲区及其大小。该缓冲区是一个多行字符串，您可以打印该字符串以检查验证器做出的决定。

在您在内核中运行任意程序时，BPF验证程序在保持系统安全性和可用性方面发挥着重要作用，尽管有时可能理解为什么要做出一些决定很困难。如果您在尝试加载程序时遇到验证问题，请不要失望。在本书的其余部分中，我们将通过一些安全的示例指导您，这些示例也将帮助您了解如何以安全的方式编写自己的程序。

下一部分将介绍BPF如何在内存中构造程序信息。程序的结构化方式将有助于弄清如何访问BPF内部，帮助您调试和了解程序的行为。

### BPF类型格式

BPF类型格式（BTP）是元数据结构的集合，可增强BPF程序，映射和功能的调试信息。 BTF包含源信息，因此我们在第5章中讨论过的BPFTool之类的工具可以向您展示对BPF数据的更丰富的解释。此元数据存储在类型是`.BTF`的可执行程序。 BTF信息有助于使程序更容易调试，但是它会大大增加二进制文件的大小，因为它需要跟踪程序中声明的所有内容的类型信息。 BPF验证程序还使用此信息来确保程序定义的结构类型正确。

BTF仅用于注释C类型。 LLVM之类的BPF编译器知道如何为您引入这些信息，因此您无需完成将这些信息添加到每个结构中的繁琐任务。但是，在某些情况下，工具链仍需要一些注释以增强程序。在后面的章节中，我们将介绍这些注释如何发挥作用以及BPFTool之类的工具如何显示此信息。

### BPF 尾部调用

BPF程序可以使用尾部调用来调用其他BPF程序。这是一个强大的功能，因为它允许您通过组合较小的BPF函数来汇编更复杂的程序。 5.2之前的内核版本对BPF程序可以生成的机器指令数量有严格的限制。将该限制设置为4,096，以确保程序可以在合理的时间内终止。但是，随着人们构建更复杂的BPF程序，他们需要一种方法来扩展由内核施加的指令限制，这就是尾部调用起作用的地方。从内核版本5.2开始，指令限制增加到一百万条指令。尾部调用嵌套也受到限制，在这种情况下，最多只能进行32个调用，这意味着您可以在一个链中组合多达32个程序，以生成更复杂的解决方案。

当您从另一个BPF程序调用BPF程序时，内核会完全重设程序上下文。记住这一点很重要，因为您可能需要一种在程序之间共享信息的方法。每个BPF程序作为其参数接收的上下文对象都不会帮助我们解决此数据共享问题。在下一章中，我们将讨论BPF映射，作为一种在多个程序之间共享数据的方式。在这里，我们还向您展示了如何使用尾部调用从一个BPF程序跳转到另一个BPF程序的示例。

### 结论

在本章中，我们引导您完成第一个代码示例，以了解BPF程序。我们还描述了可以使用BPF编写的所有程序类型。不用担心这里介绍的某些概念是否还没有意义。在本书中，我们将向您展示这些程序的更多示例。我们还介绍了BPF为确保您的程序可以安全运行而采取的重要验证步骤。

在下一章中，我们将更深入地研究这些程序并展示更多例子。我们还讨论了BPF程序如何与用户态中的对等方通信以及它们如何共享信息。
