BPF VM能够运行指令以响应内核触发的事件。但是，并非所有BPF程序都可以访问由内核触发的所有事件。当你将程序加载到BPF VM中时，需要确定要运行的程序类型。这将通知内核您的程序将在哪里触发。它还告诉BPF验证程序将允许您的程序中运行哪些帮助函数。选择程序类型后，你也选择了程序要实现的接口。此接口确保您可以访问适当类型的数据，以及您的程序是否可以直接访问网络数据包。

在本章中，我们向您展示如何编写您的第一个BPF程序。我们还将介绍可创建的不同类型的BPF程序（本书编写时）。多年来，内核开发人员一直在添加不同的入口点，可以将BPF程序附加到这些入口点。这项工作尚未完成，他们每天都在寻找新的方法来利用BPF。我们将在本章中重点介绍一些最有用的程序类型，以使您了解使用BPF可以做什么。在以后的章节中，我们将介绍许多有关如何编写BPF程序的示例。

本章还将介绍BPF验证程序在运行程序中所扮演的角色。此组件可验证您的代码可以安全执行，并帮助您编写不会导致意外结果（例如内存耗尽或内核突然崩溃）的程序。但是，让我们从编写您自己的BPF程序的基础知识开始。

### 编写 BPF 程序
编写BPF程序的最常见方法是使用LLVM编译的C子集。 LLVM是一种通用编译器，可以编译出不同类型的字节码。在这种情况下，LLVM将输出BPF汇编代码，我们稍后将其加载到内核中。本书中不会向您介绍很多BPF汇编。经过长时间的讨论，我们决定最好向您展示在特定情况下如何使用它的示例，但是您可以在网上或BPF手册页中轻松找到一些参考。我们确实会在以后的章节中显示BPF汇编的简短示例，在这些示例中，编写汇编比C更合适，例如Seccomp过滤器可控制内核中的传入系统调用。我们将在第8章中进一步讨论Seccomp。

内核提供syscall bpf，以便在编译程序后将程序加载到BPF VM中。除了加载程序外，该系统调用还用于其他操作，您将在后面的章节中看到更多用法示例。内核还提供了一些实用程序，可以为您抽象BPF程序的加载。在第一个代码示例中，我们使用这些帮助程序向您展示BPF的“ Hello World”示例：

```c
#include <linux/bpf.h>

#define SEC(NAME) __attribute__((section(NAME), used))
SEC("tracepoint/syscalls/sys_enter_execve") int bpf_prog(void *ctx) {
    char msg[] = "Hello, BPF World!"; bpf_trace_printk(msg, sizeof(msg)); 
    
    return 0;
}

char _license[] SEC("license") = "GPL";
```

在第一个程序中有一些有趣的概念。当我们要运行此程序时，我们使用SEC属性通知BPF VM。在这种情况下，当execve 系统调用被检测到时，我们将运行此BPF程序。跟踪点是内核二进制代码中的静态标记，允许开发人员注入代码以检查内核的执行情况。我们将在第4章中详细讨论跟踪点，但是现在您只需要知道execve是执行其他程序的指令即可。因此，我们将看到消息Hello，BPF World！每次内核检测到某个程序执行另一个程序时。

在此示例的最后，我们还指定了该程序的许可证。由于Linux内核是根据GPL许可的，因此它也只能加载以GPL许可的程序。如果我们将许可证设置为其他权限，内核将拒绝加载程序。我们正在使用bpf_trace_printk在内核跟踪日志中打印一条消息；您可以在 /sys/kernel/debug/tracing/trace_pipe 中找到此日志。

我们将使用clang将第一个程序编译为有效的ELF二进制文件。这是内核期望加载的格式。我们将第一个程序保存在名为bpf_program.c的文件中，以便我们对其进行编译：
```sh
clang -O2 -target bpf -c bpf_program.c -o bpf_program.o
```
在该书的代码示例中，您会在GitHub存储库中找到一些脚本来编译这些程序，因此您无需记住此clang命令。

现在，我们已经编译了第一个BPF程序，我们需要将其加载到内核中。如前所述，我们使用内核提供的特殊帮助函数来抽象出编译和加载程序的模板。该帮助函数称为load_bpf_file，它将获取一个二进制文件，然后尝试将其加载到内核中。您可以在GitHub存储库中找到该帮助函数，并在书中的所有示例都位于bpf_load.h文件中，如下所示：

```c
#include <stdio.h>
#include <uapi/linux/bpf.h>
#include "bpf_load.h"

int main(int argc, char **argv) {
    if (load_bpf_file("hello_world_kern.o") != 0) {
        printf("The kernel didn't load the BPF program\n");

        return -1; 
    }

    read_trace_pipe(); 

    return 0;
}
```

我们将使用脚本来编译该程序并将其链接为ELF二进制文件。在这种情况下，我们不需要指定目标，因为该程序不会加载到BPF VM中。我们需要使用一个外部库，编写脚本可以更轻松地将所有内容组合在一起：
```sh
    TOOLS=../../../tools
    INCLUDE=../../../libbpf/include
    HEADERS=../../../libbpf/src
    clang -o loader -l elf \
      -I${INCLUDE} \
      -I${HEADERS} \
      -I${TOOLS} \
      ${TOOLS}/bpf_load.c \
      loader.c
```

如果要运行此程序，则可以使用sudo执行此最终二进制文件：sudo ./loader。 sudo是Linux命令，它将为您提供计算机的root特权。如果您不使用sudo运行该程序，则会收到错误消息
因为大多数BPF程序只能由具有root特权的用户加载到内核中。

运行该程序时，您将开始看到我们的“ Hello, BPF World”！几秒钟后仍会显示一条消息，即使您没有使用计算机进行任何操作。这是因为在计算机屏幕后运行的程序可能正在执行其他程序。

当您停止该程序时，该消息将停止在您的终端中显示。如果是从终端的方式加载的BPF程序，当停止的时候，BPF程序就会从VM中卸载。在接下来的章节中，我们将探讨如何使BPF程序持久化，即使它们的加载程序终止后也是如此，但是我们现在还不想引入太多概念。这是一个切记的重要概念，因为在许多情况下，无论其他进程是否在运行，您都希望BPF程序在后台运行。

既然您已经了解了BPF程序的基本结构，我们就可以深入研究可以编写哪些类型的程序，从而可以访问Linux内核中的不同子系统。

### BPF 程序类型

虽然没有明确在程序中进行分类，您会很快意识到，本节中介绍的所有类型都根据其主要目的分为两类。

第一类是追踪。您编写的许多程序将帮助您更好地了解系统中正在发生的事情。它们为您提供有关系统行为及其运行硬件的直接信息。他们可以访问与特定程序有关的内存区域，并从运行进程中提取执行的追踪信息。它们还使您可以直接访问为每个特定进程分配的资源，从文件描述符到CPU和内存使用情况。

第二类是网络。这些类型的程序使您可以检查和处理系统中的网络流量。它们使您可以过滤来自网络接口的数据包，甚至完全拒绝那些数据包。可以在内核中将不同类型的程序附加到网络处理的不同阶段。这具有优点和缺点。例如，您可以在网络驱动程序收到数据包后立即将BPF程序附加到网络事件中，但是此程序将只能访问较少的有关该数据包的信息，因为内核尚不足以为您提供信息。另一方面，您可以将BPF程序附加到网络事件上，然后再将它们传递到用户空间。在这种情况下，您将获得有关数据包的更多信息，这将有助于您做出更明智的决策，但是您需要承担完全处理数据包的开销。

接下来我们介绍一些未分类的程序类型。我们将按照添加到内核的时间顺序介绍这些类型。我们将这些程序中使用最少的程序移到了本节的结尾，现在我们将重点放在对您更有用的程序上。如果您对我们在此处未详细介绍的任何程序感到好奇，可以在[man 2 bpf](http://man7.org/linux/man-pages/man2/bpf.2.html)中了解有关所有程序的更多信息。

#### 套接字过滤器程序
`BPF_PROG_TYPE_SOCKET_FILTER` 是添加到Linux内核的第一个程序类型。当您将BPF程序附加到原始套接字时，就可以访问该套接字处理的所有数据包。套接字过滤器程序不允许您修改这些数据包的内容或更改这些数据包的目的地；它们仅允许您出于可观察性目的访问它们。程序接收的元数据包含与网络栈相关的信息，例如用于传送数据包的协议类型。
我们将在第6章中详细介绍套接字过滤和其他网络程序。

#### Kprobe 程序

正如您将在第4章中讨论的追踪中所看到的那样，kprobes是可以动态附加到内核中某些调用点的函数。 BPF kprobe程序类型允许您将BPF程序用作kprobe处理程序。它们以`BPF_PROG_TYPE_KPROBE` 类型定义。 BPF VM确保您的kprobe程序始终安全运行，这是传统kprobe模块的优势。您仍然需要记住，kprobes在内核中不是稳定的入口点，因此，您需要确保kprobe BPF程序与您使用的特定内核版本兼容。

编写附加到kprobe的BPF程序时，您需要决定是将其作为函数调用中的第一条指令执行还是在调用完成时执行。您需要在BPF程序的标头中声明此行为。例如，如果您要在内核调用exec syscall时检查参数，则可以在调用开始时附加程序。在这种情况下，您需要在代码段开始处设置SEC（“kprobe/sys_exec”）。如果要检查调用exec syscall的返回值，则需要在代码段开始处设置SEC（“kr​​etprobe/ sys_exec”）。

在本书的后续章节中，我们会更多地讨论kprobes。它们是理解BPF追踪的基础。

#### 追踪点程序

这种程序类型使您可以将BPF程序附加到内核提供的跟踪点处理程序。追踪点程序以`BPF_PROG_TYPE_TRACEPOINT`类型定义。如第4章中所述，追踪点是内核代码库中的静态标记，可让您注入任意代码以进行追踪和调试。它们不如kprobes灵活，因为它们需要事先由内核定义，但是可以保证在将其引入内核后保持稳定。当您要调试系统时，这为您提供了更高的可预测性。
系统中的所有追踪点都在目录 /sys/kernel/debug/tracing/events 中定义。在这里，您将找到每个子系统，其中包括任何追踪点，并且可以将BPF程序附加到该子系统。一个有趣的事实是BPF声明了自己的追踪点，因此您可以编写检查其他BPF程序行为的BPF程序。 BPF跟踪点在 /sys/kernel/debug/tracing/events /bpf 中定义。例如，您可以在此处找到bpf_prog_load的追踪点定义。这意味着您可以编写一个BPF程序来检查何时加载其他BPF程序。

像kprobes一样，追踪点是了解BPF追踪的另一个基本要素。在接下来的章节中，我们将进一步讨论它们，并向您展示如何编写程序以使用它们。

#### XDP程序
XDP程序使您可以编写在网络数据包到达内核的早期就执行的代码。它们以 `BPF_PROG_TYPE_XDP` 类型定义。假设内核没有太多时间来处理信息本身，那么它仅从包中公开有限的信息集。由于数据包是在早期执行的，因此您对如何处理该数据包具有更高级别的控制。

XDP程序定义了几个可以控制的操作，这些操作使您可以决定如何处理数据包。您可以从XDP程序返回 XDP_PASS，这意味着应该将数据包传递到内核中的下一个子系统。您还可以返回 XDP_DROP，这意味着内核应完全忽略此数据包，并且对其不执行任何其他操作。您还可以返回XDP_TX，这意味着应将数据包转发回首先接收到数据包的网络接口卡（NIC）。

这种控制级别为网络层中许多有趣的程序打开了大门。 XDP已成为BPF的主要组件之一，这就是为什么我们在本书中包含了特定章节的原因。在第7章中，我们讨论了许多XDP用例，例如实现程序以保护您的网络免受DDoS攻击。

#### Perf事件程序

这些类型的BPF程序使您可以将BPF代码附加到Perf事件。它们以 `BPF_PROG_TYPE_PERF_EVENT` 类型定义。 Perf是内核中的性能分析器，它能够生成硬件和软件的性能数据。您可以使用它来监控许多事情，从计算机的CPU到系统上运行的任何软件。当您将BPF程序附加到Perf事件时，每次Perf生成供您分析的数据时，都将执行您的代码。

#### Cgroup套接字程序

这些类型的程序使您可以将BPF逻辑附加到控制组（cgroup）。它们以 `BPF_PROG_TYPE_CGROUP_SKB` 类型定义。它们允许cgroup控制它们所包含的进程内的网络流量。借助这些程序，您可以在将网络数据包传递到cgroup中的进程之前决定如何处理它。内核尝试传递到同一cgroup中任何进程的任何数据包都将通过每一个过滤器。同时，您可以决定cgroup中的进程通过该接口发送网络数据包时该怎么做。
如您所见，它们的行为类似于 `BPF_PROG_TYPE_SOCKET_FILTER` 程序。主要区别在于
`BPF_PROG_TYPE_CGROUP_SKB` 程序附加到cgroup内的所有进程，而不是特定进程；此行为适用于在给定cgroup中创建的当前套接字和将来的套接字。附加到cgroup的BPF程序在容器环境中很有用，在容器环境中，进程组受cgroup约束，并且您可以对所有进程应用相同的策略，而不必独立识别每个进程。 [Cillium](https://github.com/cilium/cilium)是一个受欢迎的开源项目，为Kubernetes提供负载平衡和安全功能，它广泛使用cgroup套接字程序将其策略应用于组而不是隔离的容器中。

#### Cgroup打开套接字程序

这些类型的程序允许您在cgroup中的任何进程打开网络套接字时执行代码。此行为类似于附加到cgroup套接字缓冲区的程序，与其给您访问通过网络的数据包的权限，不如让您控制进程打开新套接字时发生的情况。它们以 `BPF_PROG_TYPE_CGROUP_SOCK` 类型定义。这对于为可以打开套接字的程序组提供安全性和访问控制很有用，而不必分别限制每个进程的功能。

#### 套接字选项程序

这些类型的程序可让您在运行时修改套接字连接选项，而数据包则通过内核网络栈中的多个阶段传输。他们
附加到cgroup，就像 `BPF_PROG_TYPE_CGROUP_SOCK` 和 `BPF_PROG_TYPE_CGROUP_SKB` 一样，但是与这些程序类型不同，它们可以在连接的生命周期中多次调用。这些程序以 `BPF_PROG_TYPE_SOCK_OPS` 类型定义。

当您用这种类型创建一个BPF程序时，您的函数调用将收到一个名为op的参数，该参数代表内核将通过套接字连接执行的操作。因此，您知道在连接的生命周期中何时调用该程序。有了这些信息，您就可以访问诸如网络IP地址和连接端口之类的数据，并且可以修改连接选项以设置超时并更改给定数据包的往返延迟时间。

例如，Facebook使用它为同一数据中心内的连接设置短恢复时间目标（RTO）。 RTO是指系统或网络连接在这种情况下在出现故障后可以恢复的时间。该目标还表示在遭受无法接受的后果之前，该系统无法使用多长时间。以Facebook为例，它假设同一数据中心中的计算机应具有较短的RTO，而Facebook使用BPF程序修改此阈值。

#### 套接字映射程序

`BPF_PROG_TYPE_SK_SKB` 程序使您可以访问套接字映射和套接字重定向。正如您将在下一章中学习的那样，套接字映射允许您保留对多个套接字的引用。当拥有这些引用时，可以使用特殊的辅助函数将传入的数据包从套接字重定向到另一个套接字。当您要使用BPF实现负载平衡功能时，这很有趣。通过追踪多个套接字，您可以在它们之间转发网络数据包而无需离开内核空间。诸如Cillium和Facebook的[Katran](https://github.com/facebookincubator/katran)之类的项目广泛使用了这类程序来进行网络流量控制。

#### Cgroup 设备程序
此类程序可让您决定是否可以在给定设备上执行cgroup中的操作。这些程序以`BPF_PROG_TYPE_CGROUP_DEVICE` 类型定义。 cgroups（v1）的第一个实现具有一种机制，允许您为特定设备的设置权限。但是，cgroup的第二版迭代缺少此功能。引入了此类程序以提供该功能。同时，能够编写BPF程序使您在需要时可以更灵活地设置这些权限。

#### 套接字消息传输程序


这些类型的程序使您可以控制是否消息应该被传递到套接字。它们以 `BPF_PROG_TYPE_SK_MSG` 类型定义。当内核创建套接字时，它将套接字存储在上述套接字映射中。该映射使内核可以快速访问特定的套接字组。当您将套接字消息BPF程序附加到套接字映射时，发送到这些套接字的所有消息将在传递它们之前被程序过滤。在过滤消息之前，内核会复制消息中的数据，以便您可以读取它并决定如何处理它。这些程序有两个可能的返回值：`SK_PASS`和`SK_DROP`。如果希望内核将消息发送到套接字，则使用第一个消息；如果希望内核忽略消息而不将消息传递到套接字，则使用后一个消息。

#### 原始追踪点程序

前面我们讨论了一种访问内核中追踪点的程序。内核开发人员添加了一个新的追踪点程序，以解决访问内核保留的原始格式的跟踪点参数的需求。这种格式使您可以访问有关内核正在执行的任务的更多详细信息；但是，它的性能开销很小。大多数时候，您会希望在程序中使用常规跟踪点来避免这种性能开销，但是请记住，您还可以在需要时使用原始追踪点来访问原始参数。这些程序以`BPF_PROG_TYPE_RAW_TRACE POINT` 类型定义。

#### Cgroup套接字地址程序


使用此类程序，当用户态程序受特定cgroup控制时，您可以操纵它们附加到的IP地址和端口号。在某些情况下，如果要确保一组特定的用户态程序使用相同的IP地址和端口，则系统使用多个IP地址。当您将这些用户态程序放在同一cgroup中时，这些BPF程序使您可以灵活地操作这些绑定。这样可以确保这些应用程序的所有传入和传出连接都使用BPF程序提供的IP和端口。这些程序以 `BPF_PROG_TYPE_CGROUP_SOCK_ADDR` 类型定义。

#### 套接字重用程序

SO_REUSEPORT 是内核中的一个选项，它允许将同一主机中的多个进程绑定到同一端口。当您要在多个线程之间分配负载时，此选项可在接受的网络连接中提供更高的性能。
`BPF_PROG_TYPE_SK_REUSEPORT` 程序类型允许您编写BPF程序，这些程序hook到内核用来决定是否要重用端口的逻辑中。如果您的BPF程序返回`SK_DROP`，则可以防止程序重用同一端口，并且当您从这些BPF程序返回`SK_PASS`时，还可以通知内核遵循其自己的重用例程。