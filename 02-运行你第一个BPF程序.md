BPF VM能够运行指令以响应内核触发的事件。但是，并非所有BPF程序都可以访问由内核触发的所有事件。当你将程序加载到BPF VM中时，需要确定要运行的程序类型。这将通知内核您的程序将在哪里触发。它还告诉BPF验证程序程序中将允许哪些帮助函数。选择程序类型后，你也选择了程序要实现的接口。此接口确保您可以访问适当类型的数据，以及您的程序是否可以直接访问网络数据包。

在本章中，我们向您展示如何编写您的第一个BPF程序。我们还将介绍可创建的BPF程序的不同类型（本书编写时）。多年来，内核开发人员一直在添加不同的入口点，可以将BPF程序附加到这些入口点。这项工作尚未完成，他们每天都在寻找新的方法来利用BPF。我们将在本章中重点介绍一些最有用的程序类型，以使您了解使用BPF可以做什么。在以后的章节中，我们将介绍许多有关如何编写BPF程序的示例。

本章还将介绍BPF验证程序在运行程序中所扮演的角色。此组件可验证您的代码可以安全执行，并帮助您编写不会导致意外结果（例如内存耗尽或内核突然崩溃）的程序。但是，让我们从编写您自己的BPF程序的基础知识开始。

### 编写 BPF 程序
编写BPF程序的最常见方法是使用LLVM编译的C子集。 LLVM是一种通用编译器，可以编译出不同类型的字节码。在这种情况下，LLVM将输出BPF汇编代码，我们稍后将其加载到内核中。本书中不会向您介绍很多BPF汇编。经过长时间的讨论，我们决定最好向您展示在特定情况下如何使用它的示例，但是您可以在网上或BPF手册页中轻松找到一些参考。我们确实会在以后的章节中显示BPF汇编的简短示例，在这些示例中，编写汇编比C更合适，例如Seccomp过滤器可控制内核中的传入系统调用。我们将在第8章中进一步讨论Seccomp。

内核提供syscall bpf，以便在编译程序后将程序加载到BPF VM中。除了加载程序外，该系统调用还用于其他操作，您将在后面的章节中看到更多用法示例。内核还提供了一些实用程序，可以为您抽象BPF程序的加载。在第一个代码示例中，我们使用这些帮助程序向您展示BPF的“ Hello World”示例：

```c
#include <linux/bpf.h>
#define SEC(NAME) __attribute__((section(NAME), used))
SEC("tracepoint/syscalls/sys_enter_execve") int bpf_prog(void *ctx) {
char msg[] = "Hello, BPF World!"; bpf_trace_printk(msg, sizeof(msg)); return 0;
}
char _license[] SEC("license") = "GPL";
```