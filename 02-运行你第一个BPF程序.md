BPF VM能够运行指令以响应内核触发的事件。但是，并非所有BPF程序都可以访问由内核触发的所有事件。当你将程序加载到BPF VM中时，需要确定要运行的程序类型。这将通知内核您的程序将在哪里触发。它还告诉BPF验证程序将允许您的程序中运行哪些帮助函数。选择程序类型后，你也选择了程序要实现的接口。此接口确保您可以访问适当类型的数据，以及您的程序是否可以直接访问网络数据包。

在本章中，我们向您展示如何编写您的第一个BPF程序。我们还将介绍可创建的BPF程序的不同类型（本书编写时）。多年来，内核开发人员一直在添加不同的入口点，可以将BPF程序附加到这些入口点。这项工作尚未完成，他们每天都在寻找新的方法来利用BPF。我们将在本章中重点介绍一些最有用的程序类型，以使您了解使用BPF可以做什么。在以后的章节中，我们将介绍许多有关如何编写BPF程序的示例。

本章还将介绍BPF验证程序在运行程序中所扮演的角色。此组件可验证您的代码可以安全执行，并帮助您编写不会导致意外结果（例如内存耗尽或内核突然崩溃）的程序。但是，让我们从编写您自己的BPF程序的基础知识开始。

### 编写 BPF 程序
编写BPF程序的最常见方法是使用LLVM编译的C子集。 LLVM是一种通用编译器，可以编译出不同类型的字节码。在这种情况下，LLVM将输出BPF汇编代码，我们稍后将其加载到内核中。本书中不会向您介绍很多BPF汇编。经过长时间的讨论，我们决定最好向您展示在特定情况下如何使用它的示例，但是您可以在网上或BPF手册页中轻松找到一些参考。我们确实会在以后的章节中显示BPF汇编的简短示例，在这些示例中，编写汇编比C更合适，例如Seccomp过滤器可控制内核中的传入系统调用。我们将在第8章中进一步讨论Seccomp。

内核提供syscall bpf，以便在编译程序后将程序加载到BPF VM中。除了加载程序外，该系统调用还用于其他操作，您将在后面的章节中看到更多用法示例。内核还提供了一些实用程序，可以为您抽象BPF程序的加载。在第一个代码示例中，我们使用这些帮助程序向您展示BPF的“ Hello World”示例：

```c
#include <linux/bpf.h>
#define SEC(NAME) __attribute__((section(NAME), used))
SEC("tracepoint/syscalls/sys_enter_execve") int bpf_prog(void *ctx) {
char msg[] = "Hello, BPF World!"; bpf_trace_printk(msg, sizeof(msg)); return 0;
}
char _license[] SEC("license") = "GPL";
```

在第一个程序中有一些有趣的概念。当我们要运行此程序时，我们使用SEC属性通知BPF VM。在这种情况下，当execve 系统调用被检测到时，我们将运行此BPF程序。跟踪点是内核二进制代码中的静态标记，允许开发人员注入代码以检查内核的执行情况。我们将在第4章中详细讨论跟踪点，但是现在您只需要知道execve是执行其他程序的指令即可。因此，我们将看到消息Hello，BPF World！每次内核检测到某个程序执行另一个程序时。

在此示例的最后，我们还指定了该程序的许可证。由于Linux内核是根据GPL许可的，因此它也只能加载以GPL许可的程序。如果我们将许可证设置为其他权限，内核将拒绝加载程序。我们正在使用bpf_trace_printk在内核跟踪日志中打印一条消息；您可以在 /sys/kernel/debug/tracing/trace_pipe 中找到此日志。

我们将使用clang将第一个程序编译为有效的ELF二进制文件。这是内核期望加载的格式。我们将第一个程序保存在名为bpf_program.c的文件中，以便我们对其进行编译：
```sh
clang -O2 -target bpf -c bpf_program.c -o bpf_program.o
```
在该书的代码示例中，您会在GitHub存储库中找到一些脚本来编译这些程序，因此您无需记住此clang命令。

现在，我们已经编译了第一个BPF程序，我们需要将其加载到内核中。如前所述，我们使用内核提供的特殊帮助函数来抽象出编译和加载程序的模板。该帮助函数称为load_bpf_file，它将获取一个二进制文件，然后尝试将其加载到内核中。您可以在GitHub存储库中找到该帮助函数，并在书中的所有示例都位于bpf_load.h文件中，如下所示：

```c
#include <stdio.h>
#include <uapi/linux/bpf.h>
#include "bpf_load.h"

int main(int argc, char **argv) {
    if (load_bpf_file("hello_world_kern.o") != 0) {
        printf("The kernel didn't load the BPF program\n");

        return -1; 
    }

    read_trace_pipe(); 

    return 0;
}
```

我们将使用脚本来编译该程序并将其链接为ELF二进制文件。在这种情况下，我们不需要指定目标，因为该程序不会加载到BPF VM中。我们需要使用一个外部库，编写脚本可以更轻松地将所有内容组合在一起：
```sh
    TOOLS=../../../tools
    INCLUDE=../../../libbpf/include
    HEADERS=../../../libbpf/src
    clang -o loader -l elf \
      -I${INCLUDE} \
      -I${HEADERS} \
      -I${TOOLS} \
      ${TOOLS}/bpf_load.c \
      loader.c
```

如果要运行此程序，则可以使用sudo执行此最终二进制文件：sudo ./loader。 sudo是Linux命令，它将为您提供计算机的root特权。如果您不使用sudo运行该程序，则会收到错误消息
因为大多数BPF程序只能由具有root特权的用户加载到内核中。

运行该程序时，您将开始看到我们的“ Hello, BPF World”！几秒钟后仍会显示一条消息，即使您没有使用计算机进行任何操作。这是因为在计算机屏幕后运行的程序可能正在执行其他程序。

当您停止该程序时，该消息将停止在您的终端中显示。如果是从终端的方式加载的BPF程序，当停止的时候，BPF程序就会从VM中卸载。在接下来的章节中，我们将探讨如何使BPF程序持久化，即使它们的加载程序终止后也是如此，但是我们现在还不想引入太多概念。这是一个切记的重要概念，因为在许多情况下，无论其他进程是否在运行，您都希望BPF程序在后台运行。

既然您已经了解了BPF程序的基本结构，我们就可以深入研究可以编写哪些类型的程序，从而可以访问Linux内核中的不同子系统。

### BPF 程序类型


